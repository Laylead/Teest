<!DOCTYPE html>
<html>
<head>
  <title>Voice Call</title>
  <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.19.0.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; }
    #status { margin: 10px 0; font-weight: bold; color: #333; }
    #timer { font-family: monospace; font-size: 18px; }
    button { padding: 10px 20px; font-size: 16px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; }
    .container { text-align: center; margin-top: 50px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Voice Call</h2>
    <div id="status">Initializing...</div>
    <div>Call Duration: <span id="timer">00:00</span></div>
    <button id="leaveBtn">End Call</button>
  </div>

  <script>
    // Configuration - these should come from your backend
    const appId = "974f4c7b124940a1a6ee5e526175118d"; // Replace with your Agora App ID
    
    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const channelName = urlParams.get("channel");
    const role = urlParams.get("role");
    const uid = role === "user" ? 1 : 2; // Simple UID assignment
    
    // DOM elements
    const statusEl = document.getElementById("status");
    const timerEl = document.getElementById("timer");
    const leaveBtn = document.getElementById("leaveBtn");
    
    // Variables
    let client;
    let localAudioTrack;
    let timerInterval;
    let seconds = 0;
    let remoteUser = null;

    // Initialize Agora client
    client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

    // Format time as MM:SS
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
      const secs = (seconds % 60).toString().padStart(2, '0');
      return `${mins}:${secs}`;
    }

    // Start call timer
    function startTimer() {
      timerInterval = setInterval(() => {
        seconds++;
        timerEl.textContent = formatTime(seconds);
      }, 1000);
    }

    // Join channel and set up audio
    async function joinChannel() {
      try {
        statusEl.textContent = "Joining channel...";
        
        // Join the channel
        await client.join(appId, channelName, null, uid);
        
        if (role === "user") {
          // Create and publish local audio track
          localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
          await client.publish([localAudioTrack]);
          statusEl.textContent = "Waiting for admin to join...";
        } else {
          statusEl.textContent = "Waiting for user...";
        }

        // Set up event listeners
        client.on("user-published", handleUserPublished);
        client.on("user-unpublished", handleUserUnpublished);
        client.on("user-left", handleUserLeft);
        
      } catch (error) {
        console.error("Join channel failed:", error);
        statusEl.textContent = "Error joining channel";
        leaveChannel();
      }
    }

    // Handle when a remote user publishes
    async function handleUserPublished(user, mediaType) {
      if (mediaType !== "audio") return;
      
      try {
        // Subscribe to the remote user
        await client.subscribe(user, mediaType);
        
        // Play the remote audio track
        user.audioTrack.play();
        
        remoteUser = user;
        statusEl.textContent = "Call connected";
        startTimer();
        
      } catch (error) {
        console.error("Subscribe failed:", error);
      }
    }

    // Handle when a remote user unpublishes
    function handleUserUnpublished(user) {
      if (user.uid === remoteUser?.uid) {
        statusEl.textContent = "Other user disconnected";
        clearInterval(timerInterval);
      }
    }

    // Handle when a remote user leaves
    function handleUserLeft(user) {
      if (user.uid === remoteUser?.uid) {
        statusEl.textContent = "Call ended by other user";
        clearInterval(timerInterval);
        setTimeout(leaveChannel, 3000);
      }
    }

    // Leave the channel and clean up
    async function leaveChannel() {
      try {
        clearInterval(timerInterval);
        
        if (localAudioTrack) {
          localAudioTrack.close();
          localAudioTrack = null;
        }
        
        if (client) {
          await client.leave();
        }
        
        statusEl.textContent = "Call ended";
        leaveBtn.disabled = true;
        
        // Close the window after a delay
        setTimeout(() => {
          if (!window.opener) {
            window.location.href = role === "user" ? "user.html" : "admin.html";
          } else {
            window.close();
          }
        }, 2000);
        
      } catch (error) {
        console.error("Leave channel failed:", error);
      }
    }

    // Event listeners
    leaveBtn.addEventListener("click", leaveChannel);
    
    // Start the call when page loads
    window.addEventListener("load", () => {
      if (!channelName || !role) {
        statusEl.textContent = "Invalid call parameters";
        return;
      }
      joinChannel();
    });

    // Handle page visibility changes
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        statusEl.textContent = "Call is running in background...";
      }
    });
  </script>
</body>
</html>
